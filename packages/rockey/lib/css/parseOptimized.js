/**
 * --------------------------------------------------------------
 * --------------------------------------------------------------
 * NOTE this is autogenerated module. Does not change it manually
 * --------------------------------------------------------------
 * --------------------------------------------------------------
 */
// const validateRule = (rule, value) => {};
// const autoprefixRule = (rule, value) => {};
const cache = new Map();
const parseCss = styles => {
  const stylesParts = styles
    .trim()
    .split(';')
    .map(s => s ? s.split(':') : null)
    .filter(s => !!s);
  const key = stylesParts.toString();
  if (!key.trim()) {
    return {};
  }
  if (cache.has(key)) {
    return cache.get(key);
  }
  const stylesJson = stylesParts.reduce(
    (json, value) => {
      if (value) {
        const key = value[0].trim();
        if (json[key]) {
          // css fallback values
          let prev = Array.isArray(json[key]) ? json[key] : [json[key]];
          json[value[0].trim()] = prev.concat([
            value.slice(1).join(':').trim(),
          ]);
        } else {
          json[value[0].trim()] = value.slice(1).join(':').trim();
        }
        // validateRule(value[0], json[value[0]]);
        // json[value[0].trim()] = autoprefixRule(value.slice(1).join(':').trim());
      }
      return json;
    },
    {}
  );
  cache.set(key, stylesJson);
  return stylesJson;
};
// TODO: make this func beauty :)
const isStartsWithModificator = raw => {
  return 0 === raw.indexOf('@media') ||
    0 === raw.indexOf('@keyframes') ||
    0 === raw.indexOf('::after') ||
    0 === raw.indexOf('::before') ||
    0 === raw.indexOf('::first-letter') ||
    0 === raw.indexOf('::first-line') ||
    0 === raw.indexOf(':active') ||
    0 === raw.indexOf(':checked') ||
    0 === raw.indexOf(':disabled') ||
    0 === raw.indexOf(':empty') ||
    0 === raw.indexOf(':enabled') ||
    0 === raw.indexOf(':first-child') ||
    0 === raw.indexOf(':first-of-type') ||
    0 === raw.indexOf(':focus') ||
    0 === raw.indexOf(':hover') ||
    0 === raw.indexOf(':in-range') ||
    0 === raw.indexOf(':invalid') ||
    0 === raw.indexOf(':lang') ||
    0 === raw.indexOf(':last-child') ||
    0 === raw.indexOf(':last-of-type') ||
    0 === raw.indexOf(':link') ||
    0 === raw.indexOf(':not') ||
    0 === raw.indexOf(':nth-child') ||
    0 === raw.indexOf(':nth-last-child') ||
    0 === raw.indexOf(':nth-last-of-type') ||
    0 === raw.indexOf(':nth-of-type') ||
    0 === raw.indexOf(':only-of-type') ||
    0 === raw.indexOf(':only-child') ||
    0 === raw.indexOf(':optional') ||
    0 === raw.indexOf(':out-of-range') ||
    0 === raw.indexOf(':read-only') ||
    0 === raw.indexOf(':read-write') ||
    0 === raw.indexOf(':required') ||
    0 === raw.indexOf(':root') ||
    0 === raw.indexOf(':target') ||
    0 === raw.indexOf(':valid') ||
    0 === raw.indexOf(':visited');
};
const parse = (raw, parent) => {
  let openedBrackets = 0;
  let openedModificatorBrackets = 0;
  let styles = '';
  let component = null;
  let combinedComponents = [];
  let components = {};
  let possibleModificator = 0;
  let modificators = {};
  let modificator = '';
  let current = '';
  let currentBackup = '';
  // ---
  const mixins = [];
  let possibleMixin = false;
  let mixin = '';
  // ----
  for (let symbol of raw) {
    if (!!!component && !!!modificator) {
      if (symbol === '_') {
        possibleMixin = true;
      }
      if (possibleMixin) {
        mixin += symbol;
        if (symbol === ' ') {
          possibleMixin = false;
          mixins.push(mixin.trim());
          current = current.replace(mixin.trim(), '');
          mixin = '';
        }
      }
    }
    if (!!!component && !!!modificator) {
      if (
        !possibleModificator &&
        (symbol === '@' || symbol === ':' || symbol === '[')
      ) {
        possibleModificator = true;
        currentBackup = current;
        current = '';
      }
      if (possibleModificator && (symbol === '{' || symbol === ';')) {
        if (isStartsWithModificator(current.trim())) {
          modificator = current;
          current = '';
        } else {
          current = currentBackup + current;
          currentBackup = '';
        }
        possibleModificator = false;
      }
    }
    if (
      !possibleModificator &&
      !!!modificator &&
      (symbol === '{' && openedBrackets === 0)
    ) {
      openedBrackets++;
      let parts = current.trim().split(' ');
      if (parts.length === 1) {
        component = parts[0];
      } else {
        combinedComponents = [];
        let i = 0;
        for (i = parts.length - 1; i >= 0; i--) {
          const part = parts[i];
          const charCode = part.charCodeAt(0);
          /* All chars starts with uppercase or xxx% for animations  */ if (
            (charCode >= 65 && charCode <= 90) || part[part.length - 1] === '%'
          ) {
            combinedComponents.push(part.replace(',', '').trim());
          } else if (part[0] === '~' || part[0] === '+') {
            let size = combinedComponents.length;
            combinedComponents[size - 1] = part[0] +
              combinedComponents[size - 1];
          } else {
            break;
          }
        }
        if (combinedComponents.length) {
          component = combinedComponents[0];
          combinedComponents = combinedComponents.slice(1);
          parts = parts.slice(0, i + 1);
        } else {
          component = parts[parts.length - 1];
          parts = parts.slice(0, -1);
        }
        styles += parts.join(' ');
      }
      current = '';
      // continue;
    } else if (symbol === '{') {
      if (!!component) {
        openedBrackets++;
        if (openedBrackets !== 1) {
          current += symbol;
        }
      } else if (!!modificator) {
        openedModificatorBrackets++;
        if (openedModificatorBrackets !== 1) {
          current += symbol;
        }
      }
    } else if (symbol === '}') {
      if (!!component) {
        openedBrackets--;
      } else if (!!modificator) {
        openedModificatorBrackets--;
      }
      if (!!component) {
        if (openedBrackets === 0) {
          components[component] = parse(current, {
            parentType: 'component',
            name: component,
            combinedComponents,
          });
          combinedComponents = [];
          component = null;
          current = '';
        } else {
          current += symbol;
        }
      } else if (!!modificator) {
        if (openedModificatorBrackets === 0) {
          modificator = modificator.trim();
          modificators[modificator] = parse(current, {
            parentType: 'modificator',
            name: modificator,
          });
          modificator = '';
          current = currentBackup;
          currentBackup = '';
        } else {
          current += symbol;
        }
      }
    } else {
      current += symbol;
    }
  }
  current = currentBackup + current;
  currentBackup = '';
  if (current) {
    styles += current;
  }
  return {
    mixins,
    components,
    combinedComponents: (parent && parent.combinedComponents) || [],
    styles: parseCss(styles),
    modificators,
  };
};
export default inline => {
  return parse(inline.replace(/\r|\n/g, '').replace(/\s+/g, ' '));
};
